1. 쓰기 전 로그 (Write-Ahead Logging)
* 문제 상황
 서버가 데이터 저장에 실패해도 강한 지속성을 보장해야함
 서버가 어떤 작업을 수행하기로 했으면 서버가 실패해 메모리에서 상태를 모두 잃고 재시작하더라도 해당 작업을 수행해야 함
* 해결책
 각각의 상태 변화를 명령어 형태로 HDD의 파일에 저장
 단일 로그는 각각의 서버 프로세스에 유지 관리하고 순차적으로 추가
 순차적으로 단일 로그를 사용하면 재시작할 때 필요한 로그 작업과 이후 이어지는 온라인 작업의 처리가 단순해짐
 각각의 로그 엔트리에 고유 식별자 부여→분할 로그를 다루거나 로우 워터마크로 로그를 정리하는 등 특정 로그 작업을 구현하는데 필요
 로그 갱신은 단일 갱신 큐로 구현 가능

Alice
30
WAL Entries:
1 name Alice 2025-08-19 23:58:24.994766
2 age 30 2025-08-19 23:58:24.994766

대전제: WAL은 안전한 저장소에 저장
* 구현시 고려사항
1)
로그를 쓸 때마다 디스크에 플러시하면 로그를 사용하는 주요목적인 강한 지속성을 보장하지만 성능이 심각하게 떨어져 빠르게 병목현상이 발생 가능
플러시를 지연 또는 비동기로 수행하면 성능은 향상되지만 플러시 전에 서버가 죽으면 로그 엔트리를 잃어버릴 위험 존재
대부분의 구현체는 batch 등의 기법을 사용해 플러시 작업의 충격을 완화
2)
로그를 읽을때 로그 엔트리가 손상됐는지 감지 필요 → 로그 엔트리를 CRC 레코드와 함께 기록되며 파일을 읽을때 이를 검증
CRC는 저렴한 계산 비용으로 엔트리 손상을 감지할 수 있게 해주지만, 엔트리 종료 마커같은 간단한 기법에도 유용
로그에 마커가 없다면 로그 엔트리가 제대로 기록되지 않은 것이므로 복구할 때 폐기 가능
3)
단일 로그 파일은 관리가 어려워 저장소 용량을 전부 채울 수 있음
분할 로그나 로우 워터마크 등의 기법을 사용하여 해결
4)
WAL은 덧붙이기 전용이기 때문에 클라이언트 통신이 실패해 재시도할 때 로그에 중복 엔트리가 포함가능
로그 엔트리를 적용할 때는 중복을 무시해야 함 → 최종 상태가 동일 키에 대한 갱신이 멱등인 해시맵 같은 자료구조를 사용하면 추가적인 처리 요구 안됨
그렇지 않다면 각각의 요청에 고유 식별자를 부여해 중복을 감지하는 매커니즘 필요


구현
* WAL 기록 구조
[ length(4B) ][ payload(nB) ][ CRC32(4B) ]
length: payload 크기 (big-endian 4바이트)
payload: pickle.dumps로 직렬화된 SetValueCommand
CRC32: payload 무결성 검증용
예시) "safe"="data" 기록 시  [ 00 00 00 15 ][ pickle payload 21B ][ 1A 2B 3C 4D ]

* WAL 쓰기 (write_entry)
1) KVStore set("safe", "data") 호출
2) SetValueCommand("safe","data") 생성
3) serialize → payload 준비
4) length + payload + crc → record 생성
5) 파일 끝에 append
6) flush (durability='strong'이면 바로)
KVStore.set() → WAL.write_entry() → record -> disk

* WAL 읽기 및 CRC 검증 (recover_from_wal)
파일 오픈
반복:
    length 읽기 → payload 크기 확인
    payload 읽기
    CRC 읽기
    CRC 검증
        일치: 엔트리 정상 → WAL.entries.append(entry)
        불일치: "CRC mismatch" → 해당 엔트리 폐기
    EOF 발생 시 반복 종료
disk -> length+payload+crc -> 검증 -> 정상이면 KVStore 복구

* 손상 시 처리
시나리오 A: 마지막 엔트리 손상
WAL: [ 엔트리1 ][ 엔트리2 ][ 손상된 엔트리3 ]
복구: 엔트리1, 엔트리2 정상 적용
손상 엔트리3 무시
정상 데이터 살아남음

시나리오 B: 첫 번째 엔트리 손상
WAL: [ 손상된 엔트리1 ][ 엔트리2 ][ 엔트리3 ]
복구: 엔트리2, 엔트리3 정상 적용
손상 엔트리1 무시
첫 데이터 손실, 뒤 데이터는 살아있음

시나리오 C: 유일한 엔트리 손상
WAL: [ 손상된 엔트리1 ]
복구: 엔트리1 무시 → KVStore empty
모든 데이터 손실
